"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const AbstractTokenizer_1 = require("./AbstractTokenizer");
const type_1 = require("./type");
const fs = require("./FsPromise");
class FileTokenizer extends AbstractTokenizer_1.AbstractTokenizer {
    constructor(fd, fileSize) {
        super();
        this.fd = fd;
        this.fileSize = fileSize;
    }
    /**
     * Read buffer from file
     * @param buffer
     * @param offset is the offset in the buffer to start writing at; if not provided, start at 0
     * @param length is an integer specifying the number of bytes to read, of not provided the buffer length will be used
     * @param position is an integer specifying where to begin reading from in the file. If position is null, data will be read from the current file position.
     * @returns Promise number of bytes read
     */
    readBuffer(buffer, offset = 0, length = buffer.length, position) {
        return __awaiter(this, void 0, void 0, function* () {
            if (position) {
                this.position = position;
            }
            if (length === 0) {
                return Promise.resolve(0);
            }
            if (!length) {
                length = buffer.length;
            }
            const res = yield fs.read(this.fd, buffer, offset, length, this.position);
            if (res.bytesRead < length)
                throw new Error(type_1.endOfFile);
            this.position += res.bytesRead;
            if (res.bytesRead < length) {
                throw new Error(type_1.endOfFile);
            }
            return res.bytesRead;
        });
    }
    /**
     * Peek buffer from file
     * @param buffer
     * @param offset is the offset in the buffer to start writing at; if not provided, start at 0
     * @param length is an integer specifying the number of bytes to read, of not provided the buffer length will be used
     * @param position is an integer specifying where to begin reading from in the file. If position is null, data will be read from the current file position.
     * @param maybeless If set, will not throw an EOF error if the less then the requested length could be read
     * @returns Promise number of bytes read
     */
    peekBuffer(buffer, offset = 0, length = buffer.length, position = this.position, maybeless = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield fs.read(this.fd, buffer, offset, length, position);
            if (!maybeless && res.bytesRead < length) {
                throw new Error(type_1.endOfFile);
            }
            return res.bytesRead;
        });
    }
    /**
     * @param length Number of bytes to ignore
     * @return resolves the number of bytes ignored, equals length if this available, otherwise the number of bytes available
     */
    ignore(length) {
        return __awaiter(this, void 0, void 0, function* () {
            const bytesLeft = this.fileSize - this.position;
            if (length <= bytesLeft) {
                this.position += length;
                return length;
            }
            else {
                this.position += bytesLeft;
                return bytesLeft;
            }
        });
    }
    close() {
        return __awaiter(this, void 0, void 0, function* () {
            return fs.close(this.fd);
        });
    }
}
exports.FileTokenizer = FileTokenizer;
